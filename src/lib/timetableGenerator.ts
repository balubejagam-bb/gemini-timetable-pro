import { supabase } from "@/integrations/supabase/client";
import { env } from "./env";

interface TimetableEntry {
  section_id: string;
  subject_id: string;
  staff_id: string;
  room_id: string;
  day_of_week: number;
  time_slot: number;
  semester: number;
}

interface Department {
  id: string;
  name: string;
  code: string;
}

interface Section {
  id: string;
  name: string;
  department_id: string;
  semester: number;
}

interface Subject {
  id: string;
  name: string;
  code: string;
  hours_per_week: number;
  subject_type: string;
  department_id: string;
}

interface Staff {
  id: string;
  name: string;
  department_id: string;
  max_hours_per_week: number;
}

interface Room {
  id: string;
  room_number: string;
  capacity: number;
  room_type: string;
}

interface Timing {
  day_of_week: number;
  start_time: string;
  end_time: string;
  break_start?: string;
  break_end?: string;
  lunch_start?: string;
  lunch_end?: string;
}

interface StaffSubject {
  staff_id: string;
  subject_id: string;
}

interface GenerationData {
  departments: Department[];
  sections: Section[];
  subjects: Subject[];
  staff: Staff[];
  rooms: Room[];
  timings: Timing[];
  staffSubjects: StaffSubject[];
}

export class ClientTimetableGenerator {
  private googleApiKey: string;

  constructor() {
    const apiKey = env.GOOGLE_AI_API_KEY;
    if (!apiKey) {
      throw new Error('Google AI API key not configured. Please check your environment variables.');
    }
    this.googleApiKey = apiKey;
  }

  async generateTimetable(selectedDepartments: string[], selectedSemester: number): Promise<{
    success: boolean;
    message: string;
    entriesCount?: number;
    totalGenerated?: number;
    error?: string;
  }> {
    try {
      console.log('Starting client-side timetable generation...');
      
      // Validate input
      if (!selectedDepartments || selectedDepartments.length === 0) {
        throw new Error('At least one department must be selected');
      }
      
      if (!selectedSemester || selectedSemester < 1 || selectedSemester > 8) {
        throw new Error('Valid semester (1-8) must be provided');
      }

      // Fetch all required data
      console.log('Fetching data from database...');
      const data = await this.fetchData(selectedDepartments, selectedSemester);
      
      // Clear existing timetables
      console.log('Clearing existing timetables...');
      await this.clearExistingTimetables(data.sections.map(s => s.id));
      
      // Generate timetable using AI
      console.log('Generating timetable with AI...');
      const timetableEntries = await this.callGeminiAPI(data, selectedSemester);
      
      // Validate and save entries
      console.log('Validating and saving entries...');
      const validatedEntries = this.validateEntries(timetableEntries, selectedSemester);
      
      if (validatedEntries.length > 0) {
        await this.saveTimetable(validatedEntries);
        
        return {
          success: true,
          message: `Timetable generated successfully using client-side AI integration!`,
          entriesCount: validatedEntries.length,
          totalGenerated: timetableEntries.length
        };
      } else {
        throw new Error('No valid timetable entries were generated by AI');
      }
      
    } catch (error) {
      console.error('Client-side timetable generation error:', error);
      return {
        success: false,
        message: 'Failed to generate timetable',
        error: error.message
      };
    }
  }

  private async fetchData(selectedDepartments: string[], selectedSemester: number): Promise<GenerationData> {
    console.log(`Fetching data for departments: ${selectedDepartments.join(', ')} and semester: ${selectedSemester}`);
    
    const [departmentsResult, sectionsResult, subjectsResult, staffResult, roomsResult, timingsResult, staffSubjectsResult] = await Promise.all([
      supabase.from('departments').select('*').in('id', selectedDepartments),
      supabase.from('sections').select('*').in('department_id', selectedDepartments).eq('semester', selectedSemester),
      supabase.from('subjects').select('*').in('department_id', selectedDepartments).eq('semester', selectedSemester),
      supabase.from('staff').select('*').in('department_id', selectedDepartments),
      supabase.from('rooms').select('*'),
      supabase.from('college_timings').select('*').order('day_of_week'),
      supabase.from('staff_subjects').select('staff_id, subject_id, staff:staff_id(*), subjects:subject_id(*)')
    ]);

    // Check for errors
    const errors = [
      { name: 'departments', error: departmentsResult.error },
      { name: 'sections', error: sectionsResult.error },
      { name: 'subjects', error: subjectsResult.error },
      { name: 'staff', error: staffResult.error },
      { name: 'rooms', error: roomsResult.error },
      { name: 'timings', error: timingsResult.error },
      { name: 'staffSubjects', error: staffSubjectsResult.error }
    ].filter(item => item.error !== null);

    if (errors.length > 0) {
      console.error('Database fetch errors:', errors);
      const errorMessages = errors.map(e => `${e.name}: ${e.error.message}`).join(', ');
      throw new Error(`Failed to fetch data from database: ${errorMessages}`);
    }

    const data = {
      departments: departmentsResult.data || [],
      sections: sectionsResult.data || [],
      subjects: subjectsResult.data || [],
      staff: staffResult.data || [],
      rooms: roomsResult.data || [],
      timings: timingsResult.data || [],
      staffSubjects: staffSubjectsResult.data || []
    };

    // Log data counts for debugging
    console.log('Fetched data counts:', {
      departments: data.departments.length,
      sections: data.sections.length,
      subjects: data.subjects.length,
      staff: data.staff.length,
      rooms: data.rooms.length,
      timings: data.timings.length,
      staffSubjects: data.staffSubjects.length
    });

    // Validate essential data
    if (data.departments.length === 0) {
      throw new Error('No departments found for the selected IDs');
    }
    if (data.sections.length === 0) {
      throw new Error(`No sections found for semester ${selectedSemester} in selected departments`);
    }
    if (data.subjects.length === 0) {
      throw new Error(`No subjects found for semester ${selectedSemester} in selected departments`);
    }
    if (data.staff.length === 0) {
      throw new Error('No staff found for the selected departments');
    }
    if (data.rooms.length === 0) {
      throw new Error('No rooms found in the database');
    }

    return data;
  }

  private async clearExistingTimetables(sectionIds: string[]): Promise<void> {
    if (sectionIds.length > 0) {
      console.log(`Clearing existing timetables for ${sectionIds.length} sections...`);
      
      const { data: existingEntries, error: selectError } = await supabase
        .from('timetables')
        .select('id')
        .in('section_id', sectionIds);
        
      if (selectError) {
        console.error('Error fetching existing timetables:', selectError);
        throw new Error('Failed to fetch existing timetables for clearing');
      }
      
      console.log(`Found ${existingEntries?.length || 0} existing timetable entries to clear`);
      
      if (existingEntries && existingEntries.length > 0) {
        const { error: deleteError } = await supabase
          .from('timetables')
          .delete()
          .in('section_id', sectionIds);
        
        if (deleteError) {
          console.error('Error clearing existing timetables:', deleteError);
          throw new Error('Failed to clear existing timetables');
        }
        
        console.log(`Successfully cleared ${existingEntries.length} existing timetable entries`);
      }
    }
  }

  private async callGeminiAPI(data: GenerationData, selectedSemester: number): Promise<TimetableEntry[]> {
    // Prepare simplified data for AI
    const promptData = {
      departments: data.departments.map(d => ({ id: d.id, name: d.name, code: d.code })),
      sections: data.sections.map(s => ({ id: s.id, name: s.name, department_id: s.department_id })),
      subjects: data.subjects.map(s => ({ 
        id: s.id, 
        name: s.name, 
        code: s.code, 
        hours_per_week: s.hours_per_week,
        subject_type: s.subject_type,
        department_id: s.department_id 
      })),
      staff: data.staff.map(s => ({ 
        id: s.id, 
        name: s.name, 
        department_id: s.department_id,
        max_hours_per_week: s.max_hours_per_week 
      })),
      rooms: data.rooms.map(r => ({ 
        id: r.id, 
        room_number: r.room_number, 
        capacity: r.capacity,
        room_type: r.room_type 
      })),
      staffSubjects: data.staffSubjects.map(ss => ({
        staff_id: ss.staff_id,
        subject_id: ss.subject_id
      })),
      timings: data.timings.map(t => ({
        day_of_week: t.day_of_week,
        start_time: t.start_time,
        end_time: t.end_time,
        break_start: t.break_start,
        break_end: t.break_end,
        lunch_start: t.lunch_start,
        lunch_end: t.lunch_end
      }))
    };

    const prompt = `You are an AI timetable generator for a university. Generate a comprehensive timetable in JSON format for semester ${selectedSemester}.

CRITICAL DATABASE CONSTRAINTS (WILL CAUSE SAVE FAILURES IF VIOLATED):
1. UNIQUE(staff_id, day_of_week, time_slot) - Same staff cannot teach multiple classes at same time
2. UNIQUE(room_id, day_of_week, time_slot) - Same room cannot host multiple classes at same time  
3. UNIQUE(section_id, day_of_week, time_slot) - Same section cannot have multiple classes at same time

CRITICAL REQUIREMENTS:
1. ONLY assign staff to subjects they are authorized to teach (check staffSubjects mapping)
2. NO staff conflicts: Each staff member can only be in ONE place at any given day/time_slot
3. NO room conflicts: Each room can only host ONE class at any given day/time_slot
4. NO section conflicts: Each section can only have ONE class at any given day/time_slot
5. Lab subjects (subject_type: 'lab' or 'practical') MUST use lab-type rooms
6. Theory subjects can use any classroom or lab
7. Each subject must be scheduled for its required hours_per_week across the week
8. Time slots: 1-8 representing different periods of the day
9. Days: 1-5 (Monday=1 to Friday=5 - NO SATURDAY classes)
10. NO FREE PERIODS: Every time slot from 1-8 on each day (Mon-Fri) must have a scheduled class
11. FILL ALL SLOTS: Use available subjects to fill all 40 time slots (5 days × 8 periods)

CONFLICT RESOLUTION STRATEGY:
- If a staff member is already assigned to day X, slot Y, find different staff for other subjects at that time
- If a room is already used at day X, slot Y, find different room for other classes at that time
- Spread subject hours across different days and time slots
- Prioritize avoiding conflicts over perfect distribution
- Repeat subjects if necessary to fill all time slots (no free periods allowed)

OPTIMIZATION GOALS:
- Fill all 40 time slots (5 days × 8 periods) with classes (most important)
- Minimize scheduling conflicts 
- Balance faculty workload (respect max_hours_per_week)  
- Use room capacity efficiently
- Spread lab sessions across different days
- Minimize gaps in student schedules

DATA PROVIDED:
${JSON.stringify(promptData, null, 2)}

RESPONSE FORMAT:
Return ONLY a valid JSON array with no additional text or explanation:
[
  {
    "section_id": "uuid-here",
    "subject_id": "uuid-here", 
    "staff_id": "uuid-here",
    "room_id": "uuid-here",
    "day_of_week": 1,
    "time_slot": 1,
    "semester": ${selectedSemester}
  }
]

IMPORTANT: Before adding each entry, verify:
- This staff_id is not already used at this day_of_week + time_slot
- This room_id is not already used at this day_of_week + time_slot  
- This section_id is not already used at this day_of_week + time_slot

Generate entries for ALL sections and subjects, ensuring NO DUPLICATE assignments for the same day/time combination.`;

    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent?key=${this.googleApiKey}`,
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: prompt
            }]
          }],
          generationConfig: {
            maxOutputTokens: 8192,
            temperature: 0.1,
            topK: 1,
            topP: 0.8,
          },
          safetySettings: [
            {
              category: "HARM_CATEGORY_HARASSMENT",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            },
            {
              category: "HARM_CATEGORY_HATE_SPEECH",
              threshold: "BLOCK_MEDIUM_AND_ABOVE"
            }
          ]
        })
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Google AI API error: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    
    if (!result.candidates?.[0]?.content?.parts?.[0]?.text) {
      throw new Error('Invalid response from Google AI API');
    }

    const generatedText = result.candidates[0].content.parts[0].text;
    
    // Extract JSON from response
    const jsonMatch = generatedText.match(/\[[\s\S]*\]/);
    if (!jsonMatch) {
      throw new Error('No valid JSON found in AI response');
    }
    
    return JSON.parse(jsonMatch[0]);
  }

  private validateEntries(entries: TimetableEntry[], selectedSemester: number): TimetableEntry[] {
    console.log(`Validating ${entries.length} entries for conflicts...`);
    
    // First, filter basic validation
    const validEntries = entries.filter(entry => {
      return entry.section_id && 
             entry.subject_id && 
             entry.staff_id && 
             entry.room_id && 
             entry.day_of_week >= 1 && 
             entry.day_of_week <= 5 && // Only Monday to Friday
             entry.time_slot >= 1 && 
             entry.time_slot <= 8 &&
             entry.semester === selectedSemester;
    });

    console.log(`${validEntries.length} entries passed basic validation`);

    // Advanced conflict resolution - keep first occurrence and remove conflicts
    const conflictFreeEntries: TimetableEntry[] = [];
    const usedStaffSlots = new Map<string, TimetableEntry>();
    const usedRoomSlots = new Map<string, TimetableEntry>();
    const usedSectionSlots = new Map<string, TimetableEntry>();

    validEntries.forEach((entry, index) => {
      const staffKey = `${entry.staff_id}:${entry.day_of_week}:${entry.time_slot}`;
      const roomKey = `${entry.room_id}:${entry.day_of_week}:${entry.time_slot}`;
      const sectionKey = `${entry.section_id}:${entry.day_of_week}:${entry.time_slot}`;

      // Check all three types of conflicts
      const staffConflict = usedStaffSlots.has(staffKey);
      const roomConflict = usedRoomSlots.has(roomKey);
      const sectionConflict = usedSectionSlots.has(sectionKey);

      if (!staffConflict && !roomConflict && !sectionConflict) {
        // No conflicts, add this entry
        conflictFreeEntries.push(entry);
        usedStaffSlots.set(staffKey, entry);
        usedRoomSlots.set(roomKey, entry);
        usedSectionSlots.set(sectionKey, entry);
      } else {
        // Log specific conflicts for debugging
        const conflicts = [];
        if (staffConflict) {
          const conflictingEntry = usedStaffSlots.get(staffKey)!;
          conflicts.push(`staff ${entry.staff_id} already teaching at this time (conflicting with entry for section ${conflictingEntry.section_id})`);
        }
        if (roomConflict) {
          const conflictingEntry = usedRoomSlots.get(roomKey)!;
          conflicts.push(`room ${entry.room_id} already occupied at this time (conflicting with entry for section ${conflictingEntry.section_id})`);
        }
        if (sectionConflict) {
          const conflictingEntry = usedSectionSlots.get(sectionKey)!;
          conflicts.push(`section ${entry.section_id} already has a class at this time (conflicting with subject ${conflictingEntry.subject_id})`);
        }
        
        console.warn(`Removing conflicting entry ${index + 1}: Day ${entry.day_of_week}, Slot ${entry.time_slot} - ${conflicts.join('; ')}`);
      }
    });

    const removedCount = validEntries.length - conflictFreeEntries.length;
    if (removedCount > 0) {
      console.warn(`Removed ${removedCount} conflicting entries to prevent database constraint violations`);
    }

    // Verify no duplicates remain
    const finalStaffSlots = new Set<string>();
    const finalRoomSlots = new Set<string>();  
    const finalSectionSlots = new Set<string>();
    
    for (const entry of conflictFreeEntries) {
      const staffKey = `${entry.staff_id}:${entry.day_of_week}:${entry.time_slot}`;
      const roomKey = `${entry.room_id}:${entry.day_of_week}:${entry.time_slot}`;
      const sectionKey = `${entry.section_id}:${entry.day_of_week}:${entry.time_slot}`;
      
      if (finalStaffSlots.has(staffKey) || finalRoomSlots.has(roomKey) || finalSectionSlots.has(sectionKey)) {
        console.error('CRITICAL: Duplicate entries still present after validation!', entry);
        throw new Error('Validation failed - duplicate entries detected');
      }
      
      finalStaffSlots.add(staffKey);
      finalRoomSlots.add(roomKey);
      finalSectionSlots.add(sectionKey);
    }

    console.log(`Final validated entries: ${conflictFreeEntries.length} (guaranteed conflict-free)`);
    return conflictFreeEntries;
  }

  private async saveTimetable(entries: TimetableEntry[]): Promise<void> {
    console.log(`Attempting to save ${entries.length} timetable entries...`);
    
    if (entries.length === 0) {
      throw new Error('No entries to save');
    }

    // Log first entry for debugging
    console.log('Sample entry:', entries[0]);
    
    // Validate entries before saving
    const invalidEntries = entries.filter(entry => 
      !entry.section_id || 
      !entry.subject_id || 
      !entry.staff_id || 
      !entry.room_id ||
      typeof entry.day_of_week !== 'number' ||
      typeof entry.time_slot !== 'number' ||
      typeof entry.semester !== 'number'
    );
    
    if (invalidEntries.length > 0) {
      console.error('Invalid entries found:', invalidEntries.slice(0, 3));
      throw new Error(`Found ${invalidEntries.length} invalid entries with missing required fields`);
    }

    // Use upsert with conflict resolution to handle duplicates
    try {
      const { data, error } = await supabase
        .from('timetables')
        .upsert(entries, { 
          onConflict: 'section_id,day_of_week,time_slot',
          ignoreDuplicates: false 
        })
        .select();

      if (error) {
        console.error('Supabase upsert error:', error);
        console.error('Error details:', {
          message: error.message,
          details: error.details,
          hint: error.hint,
          code: error.code
        });
        
        // Try individual inserts with conflict resolution
        console.log('Attempting individual inserts with conflict handling...');
        let successCount = 0;
        let errorCount = 0;
        
        for (const entry of entries) {
          try {
            const { error: insertError } = await supabase
              .from('timetables')
              .insert(entry);
            
            if (insertError) {
              if (insertError.message.includes('duplicate') || insertError.message.includes('violates unique constraint')) {
                console.log(`Skipping duplicate entry: Day ${entry.day_of_week}, Slot ${entry.time_slot}`);
                errorCount++;
              } else {
                throw insertError;
              }
            } else {
              successCount++;
            }
          } catch (individualError) {
            console.error(`Failed to insert individual entry:`, individualError);
            errorCount++;
          }
        }
        
        if (successCount === 0) {
          throw new Error(`Failed to insert any timetable entries. ${errorCount} conflicts detected.`);
        }
        
        console.log(`Successfully inserted ${successCount} entries, skipped ${errorCount} conflicts`);
        return;
      }

      console.log(`Successfully saved ${data?.length || entries.length} timetable entries`);
    } catch (dbError) {
      console.error('Database operation failed:', dbError);
      throw dbError;
    }
  }
}

// Simple algorithm-based fallback generator
export class SimpleTimetableGenerator {
  async generateTimetable(selectedDepartments: string[], selectedSemester: number): Promise<{
    success: boolean;
    message: string;
    entriesCount?: number;
    error?: string;
  }> {
    try {
      console.log('Starting simple algorithm-based timetable generation...');
      
      // Fetch data
      const data = await this.fetchData(selectedDepartments, selectedSemester);
      
      // Clear existing timetables
      await this.clearExistingTimetables(data.sections.map(s => s.id));
      
      // Generate using simple algorithm
      const timetableEntries = this.generateSimpleSchedule(data, selectedSemester);
      
      if (timetableEntries.length > 0) {
        await this.saveTimetable(timetableEntries);
        
        return {
          success: true,
          message: `Timetable generated using simple algorithm (${timetableEntries.length} entries)`,
          entriesCount: timetableEntries.length
        };
      } else {
        throw new Error('Failed to generate any timetable entries');
      }
      
    } catch (error) {
      return {
        success: false,
        message: 'Failed to generate timetable using simple algorithm',
        error: error.message
      };
    }
  }

  private async fetchData(selectedDepartments: string[], selectedSemester: number): Promise<GenerationData> {
    const [departmentsResult, sectionsResult, subjectsResult, staffResult, roomsResult, timingsResult, staffSubjectsResult] = await Promise.all([
      supabase.from('departments').select('*').in('id', selectedDepartments),
      supabase.from('sections').select('*').in('department_id', selectedDepartments).eq('semester', selectedSemester),
      supabase.from('subjects').select('*').in('department_id', selectedDepartments).eq('semester', selectedSemester),
      supabase.from('staff').select('*').in('department_id', selectedDepartments),
      supabase.from('rooms').select('*'),
      supabase.from('college_timings').select('*').order('day_of_week'),
      supabase.from('staff_subjects').select('staff_id, subject_id')
    ]);

    return {
      departments: departmentsResult.data || [],
      sections: sectionsResult.data || [],
      subjects: subjectsResult.data || [],
      staff: staffResult.data || [],
      rooms: roomsResult.data || [],
      timings: timingsResult.data || [],
      staffSubjects: staffSubjectsResult.data || []
    };
  }

  private async clearExistingTimetables(sectionIds: string[]): Promise<void> {
    if (sectionIds.length > 0) {
      console.log(`Clearing existing timetables for ${sectionIds.length} sections...`);
      
      const { data: existingEntries, error: selectError } = await supabase
        .from('timetables')
        .select('id')
        .in('section_id', sectionIds);
        
      if (selectError) {
        console.error('Error fetching existing timetables:', selectError);
        throw new Error('Failed to fetch existing timetables for clearing');
      }
      
      console.log(`Found ${existingEntries?.length || 0} existing timetable entries to clear`);
      
      if (existingEntries && existingEntries.length > 0) {
        const { error: deleteError } = await supabase
          .from('timetables')
          .delete()
          .in('section_id', sectionIds);
        
        if (deleteError) {
          console.error('Error clearing existing timetables:', deleteError);
          throw new Error('Failed to clear existing timetables');
        }
        
        console.log(`Successfully cleared ${existingEntries.length} existing timetable entries`);
      }
    }
  }

  private generateSimpleSchedule(data: GenerationData, selectedSemester: number): TimetableEntry[] {
    const entries: TimetableEntry[] = [];
    const timeSlots = 8; // 8 periods per day
    const days = 5; // Monday to Friday only
    
    // Track occupied slots to avoid conflicts
    const occupiedSlots = {
      staff: new Set<string>(), // staff_id:day:slot
      rooms: new Set<string>(), // room_id:day:slot
      sections: new Set<string>() // section_id:day:slot
    };
    
    // Helper function to check if a slot is available
    const isSlotAvailable = (staffId: string, roomId: string, sectionId: string, day: number, slot: number): boolean => {
      const staffKey = `${staffId}:${day}:${slot}`;
      const roomKey = `${roomId}:${day}:${slot}`;
      const sectionKey = `${sectionId}:${day}:${slot}`;
      
      return !occupiedSlots.staff.has(staffKey) && 
             !occupiedSlots.rooms.has(roomKey) && 
             !occupiedSlots.sections.has(sectionKey);
    };
    
    // Helper function to mark a slot as occupied
    const markSlotOccupied = (staffId: string, roomId: string, sectionId: string, day: number, slot: number): void => {
      occupiedSlots.staff.add(`${staffId}:${day}:${slot}`);
      occupiedSlots.rooms.add(`${roomId}:${day}:${slot}`);
      occupiedSlots.sections.add(`${sectionId}:${day}:${slot}`);
    };
    
    // Process each section
    data.sections.forEach((section) => {
      console.log(`Processing section: ${section.name}`);
      const sectionSubjects = data.subjects.filter(s => s.department_id === section.department_id);
      
      // Schedule subjects for this section
      sectionSubjects.forEach((subject) => {
        const hoursPerWeek = subject.hours_per_week || 3;
        console.log(`Scheduling subject: ${subject.name} (${hoursPerWeek} hours/week)`);
        
        // Find staff who can teach this subject
        const eligibleStaff = data.staffSubjects
          .filter(ss => ss.subject_id === subject.id)
          .map(ss => data.staff.find(s => s.id === ss.staff_id))
          .filter(Boolean);
        
        // If no specific staff assigned, use any staff from the department
        const availableStaff = eligibleStaff.length > 0 
          ? eligibleStaff 
          : data.staff.filter(s => s.department_id === section.department_id);
        
        if (availableStaff.length === 0) {
          console.warn(`No staff available for subject: ${subject.name}`);
          return;
        }
        
        // Find appropriate rooms
        const appropriateRooms = subject.subject_type === 'lab' || subject.subject_type === 'practical'
          ? data.rooms.filter(r => r.room_type === 'lab')
          : data.rooms; // Theory can use any room
        
        if (appropriateRooms.length === 0) {
          console.warn(`No appropriate rooms for subject: ${subject.name} (${subject.subject_type})`);
          return;
        }
        
        // Schedule the required hours for this subject
        let scheduledHours = 0;
        
        for (let day = 1; day <= days && scheduledHours < hoursPerWeek; day++) {
          for (let slot = 1; slot <= timeSlots && scheduledHours < hoursPerWeek; slot++) {
            
            // Try to find available staff and room for this slot
            let assigned = false;
            
            for (const staff of availableStaff) {
              if (assigned) break;
              
              for (const room of appropriateRooms) {
                if (isSlotAvailable(staff.id, room.id, section.id, day, slot)) {
                  
                  // Create the timetable entry
                  entries.push({
                    section_id: section.id,
                    subject_id: subject.id,
                    staff_id: staff.id,
                    room_id: room.id,
                    day_of_week: day,
                    time_slot: slot,
                    semester: selectedSemester
                  });
                  
                  // Mark the slot as occupied
                  markSlotOccupied(staff.id, room.id, section.id, day, slot);
                  
                  scheduledHours++;
                  assigned = true;
                  console.log(`Scheduled: ${subject.name} - Day ${day}, Slot ${slot} - Staff: ${staff.name}, Room: ${room.room_number}`);
                  break;
                }
              }
            }
            
            if (!assigned) {
              console.warn(`Could not schedule ${subject.name} for section ${section.name} at Day ${day}, Slot ${slot} - no available staff/room`);
            }
          }
        }
        
        if (scheduledHours < hoursPerWeek) {
          console.warn(`Only scheduled ${scheduledHours}/${hoursPerWeek} hours for ${subject.name} in section ${section.name}`);
        }
      });
    });

    // FILL ALL REMAINING SLOTS (NO FREE PERIODS)
    console.log('Filling remaining slots to ensure no free periods...');
    const relevantSections = data.sections.filter(s => s.semester === selectedSemester);
    
    relevantSections.forEach(section => {
      const sectionSubjects = data.subjects.filter(s => s.department_id === section.department_id);
      
      for (let day = 1; day <= days; day++) {
        for (let slot = 1; slot <= timeSlots; slot++) {
          // Check if this slot is empty for this section
          const sectionKey = `${section.id}:${day}:${slot}`;
          if (!occupiedSlots.sections.has(sectionKey)) {
            console.log(`Filling empty slot: Section ${section.name}, Day ${day}, Slot ${slot}`);
            
            // Try to fill with any available subject/staff/room combination
            let filled = false;
            for (const subject of sectionSubjects) {
              if (filled) break;
              
              const availableStaff = data.staffSubjects
                .filter(ss => ss.subject_id === subject.id)
                .map(ss => data.staff.find(s => s.id === ss.staff_id))
                .filter(s => s !== undefined) as Staff[];

              const appropriateRooms = subject.subject_type === 'lab' || subject.subject_type === 'practical'
                ? data.rooms.filter(r => r.room_type === 'lab')
                : data.rooms;

              for (const staff of availableStaff) {
                if (filled) break;
                for (const room of appropriateRooms) {
                  if (isSlotAvailable(staff.id, room.id, section.id, day, slot)) {
                    entries.push({
                      section_id: section.id,
                      subject_id: subject.id,
                      staff_id: staff.id,
                      room_id: room.id,
                      day_of_week: day,
                      time_slot: slot,
                      semester: selectedSemester
                    });
                    
                    markSlotOccupied(staff.id, room.id, section.id, day, slot);
                    console.log(`Filled slot: ${subject.name} - Day ${day}, Slot ${slot} - Staff: ${staff.name}, Room: ${room.room_number}`);
                    filled = true;
                    break;
                  }
                }
              }
            }
            
            if (!filled) {
              console.warn(`Could not fill empty slot: Section ${section.name}, Day ${day}, Slot ${slot} - no available combinations`);
            }
          }
        }
      }
    });
    
    console.log(`Generated ${entries.length} timetable entries with conflict resolution and no free periods`);
    return entries;
  }

  private async saveTimetable(entries: TimetableEntry[]): Promise<void> {
    console.log(`Saving ${entries.length} simple timetable entries...`);
    
    if (entries.length === 0) {
      throw new Error('No entries to save');
    }

    // Validate entries
    const invalidEntries = entries.filter(entry => 
      !entry.section_id || 
      !entry.subject_id || 
      !entry.staff_id || 
      !entry.room_id
    );
    
    if (invalidEntries.length > 0) {
      console.error('Invalid entries found:', invalidEntries.slice(0, 3));
      throw new Error(`Found ${invalidEntries.length} invalid entries`);
    }

    // Use upsert with conflict resolution
    try {
      const { data, error } = await supabase
        .from('timetables')
        .upsert(entries, { 
          onConflict: 'section_id,day_of_week,time_slot',
          ignoreDuplicates: false 
        })
        .select();

      if (error) {
        console.error('Simple generator upsert error:', error);
        
        // Try individual inserts with conflict handling
        console.log('Attempting individual inserts with conflict handling...');
        let successCount = 0;
        let errorCount = 0;
        
        for (const entry of entries) {
          try {
            const { error: insertError } = await supabase
              .from('timetables')
              .insert(entry);
            
            if (insertError) {
              if (insertError.message.includes('duplicate') || insertError.message.includes('violates unique constraint')) {
                console.log(`Skipping duplicate entry: Day ${entry.day_of_week}, Slot ${entry.time_slot}`);
                errorCount++;
              } else {
                throw insertError;
              }
            } else {
              successCount++;
            }
          } catch (individualError) {
            console.error(`Failed to insert individual entry:`, individualError);
            errorCount++;
          }
        }
        
        if (successCount === 0) {
          throw new Error(`Failed to insert any timetable entries. ${errorCount} conflicts detected.`);
        }
        
        console.log(`Successfully inserted ${successCount} entries, skipped ${errorCount} conflicts`);
        return;
      }

      console.log(`Successfully saved ${data?.length || entries.length} entries`);
    } catch (dbError) {
      console.error('Simple generator database operation failed:', dbError);
      throw dbError;
    }
  }
}
